調べたことをつらつらと書いておく。

# バージョン管理対象外

.setting Eclipseの設定フォルダ
Debug Debugビルドの中間・最終成果物
Backup CubeMXがコード生成したとき、バックアップとして保存されるファイルの置き場所。
       サブディレクトリに細かく生成されるので厄介。

# コード生成(CubeMX)周り

ProjectManager設定の「Code Generator」タブにある設定。

## Generate peripheral initialization as a pair of '.c/.h' files per peripheral

ペリフェラルの初期化コードを生成するかどうか。チェックすると、uart.h,uart.cのようなファイルが生成され、
ペリフェラルの初期化コードが生成される。
チェックしない場合には生成されず、自分で初期化コードを書く必要がある。
インスタンス管理を自分でやりたい場合にはチェックを外す？

## Backup Previously generated files when re-generating

コード生成したとき、前に生成したコードのバックアップを取るかどうか。
バックアップをとる設定にした場合、バージョン管理からBackupというフォルダ名を全て除外するように設定すること。
Gitなら、.gitignoreに「Backup」と書いた行を追加すればよい。

## Keep User Code when re-generating

コード生成したとき、ユーザーコード(「USER CODE BEGIN」と「USER CODE END」に囲まれた領域)を残すかどうか。
チェックを入れておくと、既存のユーザーコード部分を抽出してマージしてくれる。
マルチバイト文字（日本語とか）は、マージするときに文字化けするので使わないこと。

## Delete previously generated files when not re-generated

チェックすると、コード生成したとき、コード生成対象でないペリフェラルのコードを消去する。

# ドライバに関して

## 割り込み周り

各ペリフェラルだけでなく、NVIC(Nested Vector Interrupt Controller)の設定が必要。
コード生成するかどうかと、プライオリティ。

##  GPIO周り

出力を変更するときは、ODR(OutputDataRegister)ではなく、BRR, BSRRを使用する。
BRRは指定したビットに対応するODRのビットを0にセットするレジスタ。
BSRRは指定したビットに対応するODRのビットを0または1にセットするレジスタ。
BSRRは下位ビットが1にするビット、上位ビットが0にするビットに割り当てられているみたい。
基本的にMCU依存なので、可能な限りHAL層ドライバのインタフェースを使った方がいい。
割り込みハンドラを使う場合には、NVICの設定を行った後、
HAL_GPIO_EXTICallbackを実装する。
引数にピン番号が入るので、GPIO_PIN_xxと比較することで、対象のピンかどうかを判定できる。


## UART周り

割り込みやDMAを使う場合には、必ずNVICの設定をすること。
割り込み送受信のインタフェースを使用する場合、
送受信完了は
huartX.gState == HAL_UART_STATE_READY
で判定する。

## タイマー周り

ドキュメントを熟読しないとなかなか難しい。
「リファレンスマニュアル」参照。
タイマーと考えるよりも、超高機能なカウンターと考えた方がいいかも。

|用語|説明|
|---|---|
|APBxクロック|タイマペリフェラルの駆動クロックのこと。ClockConfigurationに書かれている通り。APB1やらABP2やらがある。|
|プリスケーラ|分周器とかそのあたりのこと。|
|ITR|ITR1,ITR2,ITR3,ITR4とあり、タイマペリフェラル間の同期信号になる。|
|ETR|外部クロック入力信号のこと。|
|TIx|タイマーの各チャンネルに入力される入力信号のこと。|
|スレーブモード|同期動作時のふるまいのこと。|
|リセットモード|同期動作時のふるまい。トリガ入力でカウンタとプリスケーラを再初期化する。|
|ゲートモード|同期動作時のふるまい。入力が一定の条件の時だけカウントアップ/カウントダウンさせる。|
|トリガモード|同期動作時のふるまい。入力条件により、タイマのカウント開始を行う。|
|外部クロックモード1|
|外部クロックモード2|ETR信号を外部トリガ入力として動作させるモード。|

### 用途例：通常の周期タイマー

500msec毎になんらかの処理を行わせる場合など。
「Clock Source」に「Internal Clock」を設定し、プリスケーラ、カウンターペイロードの設定をする。
例えばAPBxが80MHzなら、プリスケーラを(8000-1)にすれば8000/80MHz[sec]つまり、0.1[msec]毎にカウントアップする。
それから「Counter Period」を(5000-1)にすれば、500ミリ毎にアップデートイベントが発生する。
「auto-reloadpreload」をEnableにしておくと、手動でカウンタをリセットしなくても、アップデートイベント時にリセットしてくれる。
通知はNVICで「update/global」割り込みを有効に設定し、「void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)」を実装する。









 


